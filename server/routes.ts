import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import express from "express";
import multer from "multer";
import path from "path";
import fs from "fs";
import session from "express-session";
import connectPgSimple from "connect-pg-simple";
import passport from "passport";
import { marked } from "marked";

// Import middleware
import { configureSecurityMiddleware, productionSessionConfig } from "./middleware/security";
import { requireAuth } from "./middleware/auth";

// Import route modules
import notificationsRouter from "./routes/api/notifications";
import teachersRouter from "./routes/api/teachers";
import sandboxRouter from "./routes/api/sandbox";
import schoolsRouter from "./routes/api/schools";
import parentRouter from "./routes/api/parent";

// Import existing route modules
import geolocationRoutes from "./routes/geolocation";
import enhancedGeolocationRoutes from "./routes/enhancedGeolocation";
import documentsRouter from "./routes/documents";
import authRoutes from "./routes/auth";
import subscriptionRoutes from "./routes/subscription";
import autofixRoutes from "./routes/autofix";
import multiRoleRoutes from "./routes/multiRoleRoutes";
import systemReportsRoutes from "./routes/systemReportsRoutes";
import emailPreferencesRoutes from "./routes/email-preferences-routes";
import setupNotificationRoutes from "./routes/notificationRoutes";
import configurationRoutes from "./routes/configurationRoutes";
import familyConnectionsRoutes from "./routes/familyConnections";
import teacherStudentConnections from "./routes/teacherStudentConnections";
import studentParentConnections from "./routes/studentParentConnections";
import bulkImportRoutes from "./routes/bulkImport";
import partnershipsRoutes from "./routes/partnerships";

// Import services
import { registerCriticalAlertingRoutes } from "./routes/criticalAlertingRoutes";
import { registerSiteAdminRoutes } from "./routes/siteAdminRoutes";
import { registerSubscriptionRoutes } from "./routes/subscriptionRoutes";
import { autoscaleRoutes } from "./services/sandboxAutoscaleService";

// Configure multer for file uploads
const logoStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(process.cwd(), 'public/uploads/logos');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'school-logo-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const logoUpload = multer({
  storage: logoStorage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed!'));
    }
  }
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Configure security middleware
  configureSecurityMiddleware(app);
  
  // Configure session middleware - MUST be before passport initialization
  const PgSession = connectPgSimple(session);
  app.use(session({
    ...productionSessionConfig,
    store: new PgSession({
      conString: process.env.DATABASE_URL,
      tableName: 'session',
      createTableIfMissing: true,
    })
  }));
  
  // Initialize passport middleware - MUST be after session middleware
  app.use(passport.initialize());
  app.use(passport.session());
  
  // Serve static files
  app.use('/uploads', express.static(path.join(process.cwd(), 'public/uploads')));

  // Document serving routes
  app.get('/documents/:filename', async (req, res) => {
    try {
      const filename = req.params.filename;
      const filePath = path.join(process.cwd(), 'public', 'documents', filename);
      
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: 'Document not found' });
      }

      const stat = fs.statSync(filePath);
      const fileExtension = path.extname(filename).toLowerCase();

      if (fileExtension === '.md') {
        const content = fs.readFileSync(filePath, 'utf8');
        const htmlContent = marked(content);
        const htmlPage = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>${filename}</title>
            <style>body { font-family: Arial, sans-serif; margin: 40px; }</style>
          </head>
          <body>${htmlContent}</body>
          </html>
        `;
        res.setHeader('Content-Type', 'text/html');
        res.send(htmlPage);
      } else {
        const fileStream = fs.createReadStream(filePath);
        res.setHeader('Content-Length', stat.size);
        res.setHeader('Content-Type', 'application/octet-stream');
        res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
        fileStream.pipe(res);
      }
    } catch (error: any) {
      console.error('[DOCUMENTS] Error serving document:', error);
      res.status(500).json({ message: 'Error serving document' });
    }
  });

  app.get('/documents/:filename/pdf', async (req, res) => {
    try {
      const filename = req.params.filename;
      const pdfPath = path.join(process.cwd(), 'public', 'documents', filename.replace('.html', '.pdf'));
      
      if (!fs.existsSync(pdfPath)) {
        return res.status(404).json({ message: 'PDF not found' });
      }

      const stat = fs.statSync(pdfPath);
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Length', stat.size);
      res.setHeader('Content-Disposition', `inline; filename="${path.basename(pdfPath)}"`);
      
      const fileStream = fs.createReadStream(pdfPath);
      fileStream.pipe(res);
    } catch (error: any) {
      console.error('[DOCUMENTS] Error serving PDF:', error);
      res.status(500).json({ message: 'Error serving PDF' });
    }
  });

  // Register API route modules
  app.use('/api/notifications', notificationsRouter);
  app.use('/api/teachers', teachersRouter);
  app.use('/api/sandbox', sandboxRouter);
  app.use('/api/schools', schoolsRouter);
  app.use('/api/parent', parentRouter);

  // Register existing route modules
  app.use('/api/geolocation', geolocationRoutes);
  app.use('/api/enhanced-geolocation', enhancedGeolocationRoutes);
  app.use('/api/documents', documentsRouter);
  app.use('/api/auth', authRoutes);
  app.use('/api/subscription', subscriptionRoutes);
  app.use('/api/autofix', autofixRoutes);
  app.use('/api/multi-role', multiRoleRoutes);
  app.use('/api/system-reports', systemReportsRoutes);
  app.use('/api/email-preferences', emailPreferencesRoutes);
  app.use('/api/configuration', configurationRoutes);
  app.use('/api/family-connections', familyConnectionsRoutes);
  app.use('/api/teacher-student-connections', teacherStudentConnections);
  app.use('/api/student-parent-connections', studentParentConnections);
  app.use('/api/bulk-import', bulkImportRoutes);
  app.use('/api/partnerships', partnershipsRoutes);

  // Register service routes
  try {
    registerCriticalAlertingRoutes(app);
  } catch (error) {
    console.warn('[ROUTES] Critical alerting routes failed to register:', error);
  }
  
  try {
    registerSiteAdminRoutes(app, requireAuth);
  } catch (error) {
    console.warn('[ROUTES] Site admin routes failed to register:', error);
  }
  
  try {
    registerSubscriptionRoutes(app);
  } catch (error) {
    console.warn('[ROUTES] Subscription routes failed to register:', error);
  }
  
  try {
    setupNotificationRoutes(app);
  } catch (error) {
    console.warn('[ROUTES] Notification routes failed to register:', error);
  }

  // Health check endpoint
  app.get('/api/health', (req, res) => {
    res.json({ 
      status: 'healthy', 
      timestamp: new Date().toISOString(),
      routes: 'refactored'
    });
  });

  console.log('All routes configured âœ…');

  // Create HTTP server
  const server = createServer(app);
  return server;
}